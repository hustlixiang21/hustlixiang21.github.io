<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>14_June</title>
    <url>/2022/06/14/14-june/</url>
    <content><![CDATA[<h3 id="Great-things-never-came-from-comfort-zones"><a href="#Great-things-never-came-from-comfort-zones" class="headerlink" title="Great things never came from comfort zones."></a>Great things never came from comfort zones.</h3><h3 id="伟大的事物从不来自于舒适圈。"><a href="#伟大的事物从不来自于舒适圈。" class="headerlink" title="伟大的事物从不来自于舒适圈。"></a>伟大的事物从不来自于舒适圈。</h3>]]></content>
      <categories>
        <category>一句</category>
      </categories>
      <tags>
        <tag>一句</tag>
      </tags>
  </entry>
  <entry>
    <title>15_June</title>
    <url>/2022/06/15/15-June/</url>
    <content><![CDATA[<h3 id="May-you-be-loyal-to-yourself-live-like-yourself"><a href="#May-you-be-loyal-to-yourself-live-like-yourself" class="headerlink" title="May you be loyal to yourself, live like yourself."></a>May you be loyal to yourself, live like yourself.</h3><h3 id="愿你忠于自我，活出自我"><a href="#愿你忠于自我，活出自我" class="headerlink" title="愿你忠于自我，活出自我"></a>愿你忠于自我，活出自我</h3><span id="more"></span>

<h2 id="每天早点睡觉！！！"><a href="#每天早点睡觉！！！" class="headerlink" title="每天早点睡觉！！！"></a>每天早点睡觉！！！</h2>]]></content>
      <categories>
        <category>一句</category>
      </categories>
      <tags>
        <tag>一句</tag>
      </tags>
  </entry>
  <entry>
    <title>13_June</title>
    <url>/2022/06/13/13-June/</url>
    <content><![CDATA[<p>As a child, you daydreamed and made stuff up. You were a daydream believer by day and in your right brain at night you sailed down a river of dreams.</p>
<p>So, forget about the literal attainment of your dream fot now. Focus on just going for it. By simply going for the dream, you make yourself come true.</p>
]]></content>
      <categories>
        <category>一句</category>
      </categories>
      <tags>
        <tag>一句</tag>
      </tags>
  </entry>
  <entry>
    <title>17_June</title>
    <url>/2022/06/17/17-June/</url>
    <content><![CDATA[<h3 id="NO-road-of-flowers-leads-to-glory"><a href="#NO-road-of-flowers-leads-to-glory" class="headerlink" title="NO road of flowers leads to glory."></a>NO road of flowers leads to glory.</h3><h3 id="没有一条通往光荣的道路是铺满鲜花的。"><a href="#没有一条通往光荣的道路是铺满鲜花的。" class="headerlink" title="没有一条通往光荣的道路是铺满鲜花的。"></a>没有一条通往光荣的道路是铺满鲜花的。</h3>]]></content>
      <categories>
        <category>一句</category>
      </categories>
      <tags>
        <tag>一句</tag>
      </tags>
  </entry>
  <entry>
    <title>19_June</title>
    <url>/2022/06/19/19-June/</url>
    <content><![CDATA[<h3 id="The-first-time-I-hugged-the-sky-was-when-you-held-me-above-your-head"><a href="#The-first-time-I-hugged-the-sky-was-when-you-held-me-above-your-head" class="headerlink" title="The first time I hugged the sky was when you held me above your head."></a>The first time I hugged the sky was when you held me above your head.</h3><h3 id="我第一次拥抱天空是您将我举过头顶。"><a href="#我第一次拥抱天空是您将我举过头顶。" class="headerlink" title="我第一次拥抱天空是您将我举过头顶。"></a>我第一次拥抱天空是您将我举过头顶。</h3><h3 id="祝所有的父亲父亲节快乐！！！"><a href="#祝所有的父亲父亲节快乐！！！" class="headerlink" title="祝所有的父亲父亲节快乐！！！"></a>祝所有的父亲父亲节快乐！！！</h3>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>自我激励</tag>
        <tag>亲情</tag>
      </tags>
  </entry>
  <entry>
    <title>24_May</title>
    <url>/2022/05/24/24-May/</url>
    <content><![CDATA[<h3 id="Have-a-heart-that-never-hardens-and-a-temper-that-never-tires-and-a-touch-that-never-hurts"><a href="#Have-a-heart-that-never-hardens-and-a-temper-that-never-tires-and-a-touch-that-never-hurts" class="headerlink" title="Have a heart that never hardens, and a temper that never tires, and a touch that never hurts."></a>Have a heart that never hardens, and a temper that never tires, and a touch that never hurts.</h3>]]></content>
      <categories>
        <category>一句</category>
      </categories>
      <tags>
        <tag>一句</tag>
      </tags>
  </entry>
  <entry>
    <title>A Happy 521</title>
    <url>/2022/05/18/A_happy_day/</url>
    <content><![CDATA[<h1 id="A-Happy-Day-With-My-Girlfriend"><a href="#A-Happy-Day-With-My-Girlfriend" class="headerlink" title="A Happy Day With My Girlfriend!"></a>A Happy Day With My Girlfriend!</h1><p>亲爱的宝贝，祝你521快乐，希望即将迎来三周年的我们能够一直一直走下去，我会好好爱你，也希望你能够一直陪伴在我身边。mua～</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>和宝贝在一起的时光</tag>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile入门</title>
    <url>/2022/06/19/Makefile%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Makefile概念入门"><a href="#Makefile概念入门" class="headerlink" title="Makefile概念入门"></a>Makefile概念入门</h1><p><a href="https://zhuanlan.zhihu.com/p/29910215">知乎原文链接</a></p>
<p><a href="https://www.cnblogs.com/paul-617/p/15501875.html">博客讲解链接</a></p>
<p><a href="https://blog.csdn.net/weixin_38391755/article/details/80380786">又一篇讲解</a></p>
<p>本文主要介绍怎么利用“基于目标分层”的方式去理解一个工具，写作一个概念，定义一个设计或者部署一套代码。</p>
<p>本文首先是一个“Makefile入门”，然后才是“基于目标分层的方法介绍”。</p>
<span id="more"></span>

<h2 id="关于程序编译"><a href="#关于程序编译" class="headerlink" title="关于程序编译"></a>关于程序编译</h2><p>Makefile解决的是编译的问题。Makefile最初是用来解决C语言的编译问题的，所以和C的关系特别密切，但并不是说Makefile只能用来解决C的编译问题。你用来处理Java一点问题没有，但对于Java，显然ant比Makefile处理得更好。</p>
<p>比如说，你有foo.c, bar.c, main.c三个C文件，你要编译成一个app.executable，你会怎么做呢？你会执行这样的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -Wall -c foo.c -o foo.o</span><br><span class="line">gcc -Wall -c bar.c -o bar.o</span><br><span class="line">gcc -Wall -c main.c -o main.o</span><br><span class="line">gcc main.o foo.o bar.o -lpthread -o app.executable</span><br></pre></td></tr></table></figure>

<p>按照程序猿的惯例，凡是要一次次重新执行的命令，都应该写成脚本。所以，简单来说，你会把上面这个命令序列写成一个build.sh，每次编译你只要执行这个脚本问题就解决了。</p>
<p>但这个脚本有问题，假设我修改了foo.c，但我没有修改bar.c和main.c，那么执行这个脚本是很浪费的，因为它会无条件也重新编译bar.c和main.c。</p>
<p>这个脚本更合理的写法应该是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ foo.o -ot foo.c ] &amp;&amp; gcc -Wall -c foo.c -o foo.o</span><br><span class="line">[ bar.o -ot bar.c ] &amp;&amp; gcc -Wall -c bar.c -o bar.o</span><br><span class="line">[ main.o -ot main.o] &amp;&amp; gcc -Wall -c main.c -o main.o</span><br><span class="line">[ app.executable -ot main.o ] &amp;&amp; [ app.executable -ot foo.o ] &amp;&amp; [ app.executable -ot bar.o ] &amp;&amp; gcc main.o foo.o bar.o -lpthread -o app.executable</span><br></pre></td></tr></table></figure>

<p>如果你面对一个问题，不要尝试重新去定义这个问题，而是看它和原来的问题相比，多出来的问题是什么，尝试解决那个多出来的问题就好了。那么这里，多出来的问题就是文件修改时间比较。这个就是Makefile要解决的基本问题了。我们定义一种新的“脚本语言”（只是不用sh&#x2F;bash&#x2F;tch来解释，而是用make来解释），可以用很简单的方法来说明我们需要做的文件比较。这样上面的脚本就可以写成这个样子了：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample1</span></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line">  gcc -Wall -c foo.c -o foo.o</span><br><span class="line"><span class="section">bar.o: bar.c</span></span><br><span class="line">  gcc -Wall -c bar.c -o woo.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">  gcc -Wall -c main.c -o main.o</span><br><span class="line"><span class="section">app.executable: foo.o bar.o main.o</span></span><br><span class="line">  gcc main.o foo.o bar.o -lpthread -o app.executable</span><br></pre></td></tr></table></figure>

<p>上面那个Makefile中，foo.o: foo.c定义了一个<strong>“依赖”</strong>，说明foo.o是靠foo.c编译成的，它后面缩进的那些命令，就是简单的shell脚本，称为**规则(rule)**。而Makefile的作用是定义一组依赖，当被依赖的文件比依赖的文件新，就执行规则。这样，前面的问题就解决了。</p>
<p>IDE中封装了Makefile得使用，但是想要具体控制特定文件的编译细节，最终仍然需要面对这些问题，IDE和make工具的对比，两者解决的是问题的不同层次。</p>
<p>Makefile中的依赖定义构成了一个依赖链（树），比如上面这个Makefile中，app.executable依赖于main.o，main.o又依赖于main.c，所以，当你去满足app.executable（这个目标）的依赖的时候，它首先去检查main.o的依赖，直到找到依赖树的叶子节点(main.c），然后进行时间比较。这个判断过程由make工具来完成，所以，和一般的脚本不一样。Makefile的执行过程不是基于语句顺序的，而是基于依赖链的顺序的。<img src="https://pic4.zhimg.com/80/v2-90371e6fcdf8f515a68dab7404ed4f43_1440w.jpg" alt="依赖树"></p>
<h2 id="phony依赖"><a href="#phony依赖" class="headerlink" title="phony依赖"></a>phony依赖</h2><p>make命令执行的时候，后面跟一个“目标”（不带参数的话默认是第一个依赖的目标），然后以这个目标为根建立整个依赖树。依赖树的每个节点是一个文件，任何时候我们都可以通过比较每个依赖文件和被依赖文件的时间，以决定是否需要执行“规则”</p>
<p>但有时，我们希望某个规则<strong>总是被执行</strong>。这时，很自然地，我们会定义一下<strong>永远都不会被满足</strong>的依赖。</p>
<p>可能会这么写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test:</span></span><br><span class="line">  DEBUG=1 ./app.executable</span><br></pre></td></tr></table></figure>

<p>test这个文件永远都不会被产生，所以，你只要执行这个依赖，rule是必然会被执行的。这种形式看起来很好用，但由于make工具默认认为你这是个文件，当它成为依赖链的一部分的时候，很容易造成各种误会和处理误差。</p>
<p>所以，简化起见，Makefile允许你显式地把一个依赖目标定义为**假的(Phony)**：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line"> DEBUG=1 ./app.executable</span><br></pre></td></tr></table></figure>

<p>这样make工具就不用多想了，也不用检查test这个文件的时间了，反正test就是假的，如果有人依赖它，无条件执行就对了。</p>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>前面的sample1明显还是有很多多余的成份，这些多余的成份可以简单通过引入“宏”定义来解决，比如上面的Makefile，我们把重复的东西都用宏来写，就成了这样了：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample2</span></span><br><span class="line">CC=gcc -Wall -c</span><br><span class="line">LD=gcc</span><br><span class="line"></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line"> <span class="variable">$(CC)</span> foo.c -o foo.o</span><br><span class="line"><span class="section">bar.o: bar.c</span></span><br><span class="line"> <span class="variable">$(CC)</span> bar.c -o bar.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line"> <span class="variable">$(CC)</span> main.c -o main.o</span><br><span class="line"><span class="section">app.executable: foo.o woo.o main.o</span></span><br><span class="line"> <span class="variable">$(LD)</span> main.o foo.o bar.o -o app.executable</span><br></pre></td></tr></table></figure>

<p>还是有“多余”的成份在，因为明明依赖中已经写了foo.o了，rule中还要再写一次，我们可以把依赖的对象定义为$@，被依赖的对象定义为$^（这是当前gnumake的设计），这样就可以进一步化简：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample3</span></span><br><span class="line">CC=gcc -Wall -c</span><br><span class="line">LD=gcc</span><br><span class="line"></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">bar.o: bar.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">app.executable: foo.o woo.o main.o</span></span><br><span class="line">  <span class="variable">$(LD)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>很明显，这还是有重复，我们可以把重复的定义写成通配符：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample4</span></span><br><span class="line">CC=gcc -Wall -c</span><br><span class="line">LD=gcc</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line"> <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line"><span class="section">woo.o: woo.c</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line"><span class="section">app.executable: foo.o woo.o main.o</span></span><br><span class="line"> <span class="variable">$(LD)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>实际上，你要化简，还有很多手段，比如gnumake其实是默认定义了一组rule的，上面这个整个你都可以不写，就这样就可以了：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample5</span></span><br><span class="line">LDLIBS=-lpthead</span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ=$(SRC:.c=.o)</span><br><span class="line"><span class="section">app.executable: <span class="variable">$(OBJ)</span></span></span><br><span class="line"><span class="comment">#看不懂</span></span><br></pre></td></tr></table></figure>

<p>这里其实没有定义.o到.c的依赖，但gnumake默认如果.c存在，.o就依赖对应的.c，而.o到.c的rule，是通过宏默认定义的。你只要修改CC，LDLIBS这类的宏，就能解决大部分问题了。所以你又省掉了一组定义，这就可以写得很短。</p>
<h2 id="头文件问题"><a href="#头文件问题" class="headerlink" title="头文件问题"></a>头文件问题</h2><p>现在我们把问题搞得复杂一点，增加三个头文件。比如foo.h, bar.h和common.h，前两者定义foo.c和bar.c的对外接口，给main.c使用，common.h定义所有文件都要用到的通用定义（foo.h和woo.h中包含common.h)。这样前面这个sample1就有毛病了。照理说，foo.h更新的时候，foo.o和main.o都需要重新编译，但根据那个定义，根本就没有这个比较。</p>
<p>我们的定义必须写成这个样子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample4+</span></span><br><span class="line">CC=gcc -Wall -c</span><br><span class="line">LD=gcc</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">foo.o: foo.c foo.h common.h</span></span><br><span class="line"><span class="section">bar.o: bar.c bar.h common.h</span></span><br><span class="line"><span class="section">main.o: main.c foo.h bar.h common.h</span></span><br><span class="line"><span class="section">app.executable: foo.o bar.o main.o</span></span><br><span class="line">  <span class="variable">$(LD)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>(注：这个例子我们在.o.c依赖的规则中使用了$&lt;宏，它和$^的区别是，它不包括依赖列表中的所有文件，而仅仅是列表中的第一个文件）</p>
<p>这就又增加了复杂度了——头文件包含关系一变化，我就得更新这个Makefile的定义。这带来了升级时的冗余工作。按我们前面考虑一样的策略，我们尝试在已有的名称空间上解决这个问题。Makefile已经可以定义依赖了，但我们不知道这个依赖本身。这个事情谁能解决？——把这个过程想一下——其实已经有人解决这个问题了，这个包含关系谁知道嘛？当然是编译器。编译器都已经用到那个头文件了，当然是它才知道这种包含关系是什么样的。比如gcc本身直接就提供了-M系列参数，可以自动帮你生成依赖关系。比如你执行gcc -MM foo.c就可以得到</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">foo.o: foo.c foo.h common.h</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>本文引自开头的链接，由于能力有限及需求不高，剩余的看的不是很懂，目前就到这里。</p>
</blockquote>
]]></content>
      <categories>
        <category>CS学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>makefile基础</tag>
        <tag>cs工具</tag>
      </tags>
  </entry>
  <entry>
    <title>22_June</title>
    <url>/2022/06/22/22-June/</url>
    <content><![CDATA[<h3 id="The-only-person-you-are-destined-to-become-is-the-person-you-decide-to-be"><a href="#The-only-person-you-are-destined-to-become-is-the-person-you-decide-to-be" class="headerlink" title="The only person you are destined to become is the person you decide to be."></a>The only person you are destined to become is the person you decide to be.</h3><h3 id="你注定只会成为你决心要变成的那个人。"><a href="#你注定只会成为你决心要变成的那个人。" class="headerlink" title="你注定只会成为你决心要变成的那个人。"></a>你注定只会成为你决心要变成的那个人。</h3>]]></content>
      <categories>
        <category>一句</category>
      </categories>
      <tags>
        <tag>一句</tag>
      </tags>
  </entry>
  <entry>
    <title>git入门</title>
    <url>/2022/07/05/git%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="git入门"><a href="#git入门" class="headerlink" title="git入门"></a>git入门</h1><p>依托清华大学暑培进行一些实操，参照书籍<a href="https://git-scm.com/book/en/v2">《pro git》</a>。</p>
<p>同时推荐一个<a href="https://learngitbranching.js.org/?locale=zh_CN">快速入门的网站</a>。能够更加增加对于分支的理解。</p>
<span id="more"></span>

<h2 id="什么是git？"><a href="#什么是git？" class="headerlink" title="什么是git？"></a>什么是git？</h2><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理项目。</p>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>能够轻易的将仓库里的东西恢复到上一次的<strong>commit</strong>。</p>
<p>原理：采用快照的方式进行版本控制。</p>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>我的理解就是能够多人多台主机在不同时空进行同一个开发，且互不影响，最后统一提交。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>分为工作区、暂存区与版本库，文件夹中有一个.git文件，里面是暂存区和版本库，而.git外的区域就是工作区。</p>
<p><img src="https://pic2.zhimg.com/80/v2-99d8bb59ba479252bfae5f71554b33aa_1440w.png" alt="img"></p>
<h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>首先使用命令行进入当前的文件夹。</p>
<p>需要初始化当前的文件夹建立一个空的仓库，使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p><img src="https://pica.zhimg.com/80/v2-099c25239375be8b37a05910cbc07143_1440w.png" alt="img"></p>
<p>将所需文件添加进入缓存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;文件名&gt;</span><br></pre></td></tr></table></figure>

<p>将缓存区内的文件commit进入版本库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit </span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;这个时候一般会弹出默认的编辑器，要求对本次的提交进行一些描述，通常需要统一标准，写的清楚详细。&#x3D;&#x3D;</p>
<p><img src="https://pic1.zhimg.com/80/v2-245d2877ae4fc8dfe9e8b64e3e8081e2_1440w.png" alt="img"></p>
<h3 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h3><p>查看commit日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-1025580221e635d84f2ebf13e632c0fe_1440w.png" alt="img"></p>
<p>查看git状态，即缓存区内的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/80/v2-0edf6701fd8e886a2a037d0cc283edb9_1440w.png" alt="img"></p>
<p>修改<strong>工作区文件</strong>与上次的commit进行比对，并输出不同的地方。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<p><img src="https://picx.zhimg.com/80/v2-0c8cd096128899e7b95e084d974e0214_1440w.png" alt="img"></p>
<h3 id="分支和远程操作"><a href="#分支和远程操作" class="headerlink" title="分支和远程操作"></a>分支和远程操作</h3><p>参见文章开始处的网站教学，生动自然令人印象深刻。</p>
]]></content>
      <categories>
        <category>CS学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>git</tag>
        <tag>CS工具</tag>
      </tags>
  </entry>
  <entry>
    <title>useful_links</title>
    <url>/2022/05/25/useful-links/</url>
    <content><![CDATA[<p>书籍资源:<a href="https://github.com/frankcbliu/CS-Books-PDF">https://github.com/frankcbliu/CS-Books-PDF</a></p>
<p>算法知识讲解:<a href="https://oi-wiki.org/graph/">https://oi-wiki.org/graph/</a></p>
<p>cs自学指南:<a href="https://csdiy.wiki/">https://csdiy.wiki</a></p>
<p>学堂在线（类似于mook的课程网站）:</p>
<p><a href="https://www.xuetangx.com(强烈推荐清华大学郑莉老师讲的c++程序设计)/">https://www.xuetangx.com(强烈推荐清华大学郑莉老师讲的c++程序设计)</a></p>
<span id="more"></span>

<p>计算机实用技术（学堂在线）:<br><a href="https://www.xuetangx.com/learn/THUSAST08091234567890/THUSAST08091234567890/8571842/video/13167559">https://www.xuetangx.com/learn/THUSAST08091234567890/THUSAST08091234567890/8571842/video/13167559</a></p>
<p>数据结构邓俊辉（学堂在线）:<br><a href="https://www.xuetangx.com/learn/THU08091000384/THU08091000384/10322765/video/17436706?channel=i.area.manual_search">https://www.xuetangx.com/learn/THU08091000384/THU08091000384/10322765/video/17436706?channel=i.area.manual_search</a></p>
<p>代码学习在线网站:</p>
<p><a href="https://www.freecodecamp.org/">https://www.freecodecamp.org/</a><br><a href="https://www.codecademy.com/learn">https://www.codecademy.com/learn</a></p>
<p>清华大学考研资料:<br><a href="https://github.com/Wsky51/THU-CS912-kaoyan">https://github.com/Wsky51/THU-CS912-kaoyan</a></p>
<p>github配置hexo搭建个人博客:<br><a href="https://zhuanlan.zhihu.com/p/60578464">https://zhuanlan.zhihu.com/p/60578464</a><br><a href="https://zhuanlan.zhihu.com/p/36912355?utm_source=wechat_session&amp;utm_medium=social&amp;s_r=0">https://zhuanlan.zhihu.com/p/36912355?utm_source=wechat_session&amp;utm_medium=social&amp;s_r=0</a> </p>
<p>清华学长oop笔记<br><a href="https://c7w.tech/oop-note/">https://c7w.tech/oop-note/</a></p>
<p>清华学长笔记：<br><a href="https://cloud.tsinghua.edu.cn/d/598bef9e3b844f17bf59/">https://cloud.tsinghua.edu.cn/d/598bef9e3b844f17bf59/</a></p>
<p>linux学习笔记:<br><a href="https://zq99299.github.io/linux-tutorial/">https://zq99299.github.io/linux-tutorial/</a></p>
<p>vim编辑器配置插件:</p>
<p>MIT lecture of vim：<br><a href="https://missing.csail.mit.edu/2020/editors/">https://missing.csail.mit.edu/2020/editors/</a> （这上面有老师的配置）</p>
<p>找插件的网站:<br><a href="https://vimawesome.com/">https://vimawesome.com</a></p>
<p>超级强大的vim配置(vimplus)–续集:<br><a href="https://www.cnblogs.com/highway-9/p/5984285.html">https://www.cnblogs.com/highway-9/p/5984285.html</a></p>
<p>item2 + zsh + oh-my-zsh美化:</p>
<p>教程:<a href="https://zhuanlan.zhihu.com/p/145437836">https://zhuanlan.zhihu.com/p/145437836</a></p>
<p>icon:<a href="https://www.nerdfonts.com/cheat-sheet">https://www.nerdfonts.com/cheat-sheet</a></p>
]]></content>
      <categories>
        <category>学习资源</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>linux实训</title>
    <url>/2022/05/25/%E5%A4%B4%E5%93%A5linux%E5%AE%9E%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="根目录文件及其用处"><a href="#根目录文件及其用处" class="headerlink" title="根目录文件及其用处"></a>根目录文件及其用处</h1><p><img src="https://pic2.zhimg.com/80/v2-faec5535f8d7f0d4589adfa8135fa98a_1440w.png"></p>
<span id="more"></span>

<h1 id="Linux之用户管理"><a href="#Linux之用户管理" class="headerlink" title="Linux之用户管理"></a>Linux之用户管理</h1><h2 id="创建-x2F-删除新用户"><a href="#创建-x2F-删除新用户" class="headerlink" title="创建&#x2F;删除新用户"></a>创建&#x2F;删除新用户</h2><h3 id="Linux创建用户命令"><a href="#Linux创建用户命令" class="headerlink" title="Linux创建用户命令"></a>Linux创建用户命令</h3><p>Linux中使用<code>useradd</code>命令来创建一个新用户。<br>命令格式格式：<code>useradd [命令参数] 参数</code><br>常见命令参数：</p>
<ul>
<li>d&lt;登入目录&gt;：指定用户登入时的启始目录；</li>
<li>D：查看或变更预设值；</li>
<li>g&lt;群组&gt;：指定用户所属的群组；</li>
<li>m：自动建立用户的登入目录；</li>
<li>M：不要自动建立用户的登入目录；</li>
<li>s：指定用户登入后所使用的shell。</li>
</ul>
<p><code>useradd</code>必须以root权限才能执行，如果是普通用户想创建一个新用户时，需要在命令前加<code>sudo</code>命令来提升权限为root权限。</p>
<p>案例演示：</p>
<p>1.查看useradd系统默认属性值，使用命令<code>useradd -D</code><br><img src="https://pic1.zhimg.com/80/v2-cd4d69f535cad63f82850712990ef2a7_1440w.png" alt="截屏2022-05-17 20.55.31.png"></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GROUP</td>
<td>指新创建的用户将被添加到用户组ID为100的公共用户组中</td>
</tr>
<tr>
<td>HOME</td>
<td>指新创建的用户将在&#x2F;home目录下创建一个HOME账户</td>
</tr>
<tr>
<td>INACTIVE</td>
<td>指当密码逾期时，用户将不会被禁用</td>
</tr>
<tr>
<td>EXPIRE</td>
<td>指新创建的用户不会在设定日期被设置为逾期</td>
</tr>
<tr>
<td>SHELL</td>
<td>指新创建的用户使用&#x2F;bin&#x2F;sh(也就是bash)作为默认shell</td>
</tr>
<tr>
<td>SKEL</td>
<td>指系统会将&#x2F;etc&#x2F;skel目录中的内容复制到新创建的用户的HOME目录</td>
</tr>
<tr>
<td>CREATE_MAIL_SPOOL</td>
<td>指系统不会在邮件目录中创建一个文件用于新创建用户账户接受邮件</td>
</tr>
</tbody></table>
<p>2.创建新用户<br><img src="https://pic1.zhimg.com/80/v2-b25c232976216fcb6f3f803aeff450bd_1440w.png" alt="截屏2022-05-17 21.00.31.png"></p>
<p>Linux中用户信息是保存在<code>/etc/passwd</code>文件中，我们可以使用命令<code>tail</code> <code>/etc/passwd</code>命令查看<code>/etc/passwd</code>文件最后10行中是否存在刚刚新创建的testUser用户信息。</p>
<p><img src="https://pic1.zhimg.com/80/v2-7cbdd2c9f33f3d821619f37e443faf69_1440w.png" alt="截屏2022-05-17 21.03.00.png"></p>
<h3 id="Linux删除用户命令"><a href="#Linux删除用户命令" class="headerlink" title="Linux删除用户命令"></a>Linux删除用户命令</h3><p>Linux中使用<code>userdel</code>命令来删除一个已经存在的用户。<br>命令格式：<code>userdel [命令参数] 参数</code><br>常见命令参数：</p>
<ul>
<li>f：强制删除用户，即使用户当前已登录；</li>
<li>r：删除用户的同时，删除与用户相关的所有文件。</li>
</ul>
<p><code>userdel</code>必须以root权限才能执行，如果是普通用户想使用该命令时，需要在命令前加sudo命令来提升权限为root权限。</p>
<p>案例演示:</p>
<ol>
<li>使用userdel命令删除一个已经存在的用户testUser，并且自动删除其家目录文件。</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-cc94c16290b8db6a31084c63f2cfbc1c_1440w.png" alt="截屏2022-05-17 21.07.46.png"></p>
<h2 id="Linux-用户密码管理"><a href="#Linux-用户密码管理" class="headerlink" title="Linux 用户密码管理"></a>Linux 用户密码管理</h2><h3 id="用户密码存放地及方式"><a href="#用户密码存放地及方式" class="headerlink" title="用户密码存放地及方式"></a>用户密码存放地及方式</h3><p>Linux中用户的登录密码是存放在<code>/etc/shadow</code>文件中，<code>/etc/shadow</code>文件中存放的是加密过后的密码，所以在<code>/etc/shadow</code>文件中看到的密码是加密过后的密文。</p>
<p><img src="https://pic3.zhimg.com/80/v2-56da6c940f5d0647ee221877032f9006_1440w.png" alt="截屏2022-05-17 21.12.04.png"></p>
<p>可以看到第一个冒号前是用户名，用户名是以明文的方式存放。</p>
<p>在第一个冒号和第二个冒号之间存放的是加密过后的密码，密码是以密文的方式存放，其中密文是由用户密码和其它信息加密后组成的，这里不做详细讲解，我们只需要知道如果第一个冒号和第二个冒号之间是*或者!或者空，则表示该用户没有密码，否则，则表示该用户是有密码。</p>
<h3 id="使用passwd命令修改用户密码"><a href="#使用passwd命令修改用户密码" class="headerlink" title="使用passwd命令修改用户密码"></a>使用passwd命令修改用户密码</h3><p>命令格式：<code>passwd [命令参数] 参数</code></p>
<p>常见命令参数：</p>
<ul>
<li>d 删除密码；</li>
<li>l 停止账号使用；</li>
<li>S 显示密码信息。</li>
</ul>
<p>passwd必须以root权限才能执行，如果是普通用户想执行passwd时，需要在命令前加sudo命令来提升权限为root权限。</p>
<p>案例演示：</p>
<ol>
<li>使用useradd命令来新创建一个用户，使用passwd命令来设置登录密码。</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-d5b2e731ec72100890b67f8135105474_1440w.png" alt="截屏2022-05-17 21.15.41.png"></p>
<p>使用useradd命令创建一个新用户(test)，此时test用户是没有密码的，所以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 1 /etc/shadow</span><br><span class="line"><span class="built_in">tail</span>用法：-n, --lines=[+]NUM</span><br><span class="line">output the last NUM lines, instead of the last 10; or use -n +NUM to output starting with line NUM</span><br></pre></td></tr></table></figure>
<p>命令查看&#x2F;etc&#x2F;shadow文件的最后一行可以看出test用户密码部分为!。</p>
<p>使用passwd命令为test用户设置密码时，可以看到需要输入两次密码，目的是为了确保两次输入的密码一致。当设置完密码后，可以看到&#x2F;etc&#x2F;shadow文件中test用户的密码部分已经为加密过后的密文。</p>
<ol start="2">
<li>使用passwd命令来清除用户的密码。</li>
</ol>
<p><img src="https://pica.zhimg.com/80/v2-103024acdf47401fc675a536612fc29d_1440w.png" alt="截屏2022-05-17 21.22.23.png"></p>
<p>使用passwd命令清除用户test的登录密码，使用tail -n 1 &#x2F;etc&#x2F;shadow命令查看&#x2F;etc&#x2F;shadow文件的最后一行可以看出test用户密码部分为空，此时test用户是没有密码的。</p>
<h3 id="使用chpasswd命令修改用户密码"><a href="#使用chpasswd命令修改用户密码" class="headerlink" title="使用chpasswd命令修改用户密码"></a>使用chpasswd命令修改用户密码</h3><p><code>chpasswd</code>命令通常是用于批量修改用户密码，从标准输入批量读取成对的用户名和密码，其中输入的用户名和密码的格式为: 用户名:密码 </p>
<p>例如要批量更新用户密码，将用户名和密码写入到一个文件中，格式如下所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-3614610da6fdd274a3230a23dd8df26a_1440w.png" alt="截屏2022-05-17 21.24.16.png"><br>然后执行执行如下命令来更新密码：</p>
<p>sudo chpasswd &lt; batch.txt</p>
<p>“&lt;”代表着重定向</p>
<p>命令格式：<code>chpasswd [命令参数] 参数</code></p>
<p>常见命令参数</p>
<ul>
<li>e：输入的密码是加密后的密文；</li>
<li>h：显示帮助信息并退出。</li>
</ul>
<p>chpasswd必须以root权限才能执行，如果是普通用户执行时，需要在命令前加sudo命令来提升权限为root权限。</p>
<h2 id="Linux用户权限切换"><a href="#Linux用户权限切换" class="headerlink" title="Linux用户权限切换"></a>Linux用户权限切换</h2><h3 id="图形化界面登录"><a href="#图形化界面登录" class="headerlink" title="图形化界面登录"></a>图形化界面登录</h3><p>Linux中添加用户后，用户在图形界面登录系统的方式和Windows一样，都是选择要登录的用户后直接输入登录密码即可。</p>
<p>案例演示：</p>
<ol>
<li>添加一个新用户，并且设置登录密码，然后在图形界面登录。</li>
</ol>
<p><img src="https://picx.zhimg.com/80/v2-09a98a0817379f8c0b43104f19f9de87_1440w.png" alt="截屏2022-05-17 21.28.44.png"></p>
<h3 id="使用login命令登录"><a href="#使用login命令登录" class="headerlink" title="使用login命令登录"></a>使用login命令登录</h3><p>login命令是让用户登录系统，可通过它的功能随时更换登入身份。当&#x2F;etc目录里含名称为nologin的文件时，系统只允许root帐号登入系统，其他用户一律不准登入。</p>
<p>当使用login命令登录系统后，可以使用logout命令或者exit命令来退出当前用户登录，返回到登录前的用户状态。</p>
<p>命令格式：<code>login [命令参数] 参数</code></p>
<p>参数为登录的用户名，可以不输入登录的用户名，直接输入login命令后回车，然后根据提示再输入用户名和密码。</p>
<p>常见命令参数:</p>
<ul>
<li>p：告诉login指令不销毁环境变量；</li>
<li>h：指定远程服务器的主机名。</li>
</ul>
<p>login必须以root权限才能执行，如果是普通用户执行时，需要在命令前加sudo命令来提升权限为root权限。</p>
<p>案例演示:</p>
<ol>
<li>使用login命令来登录系统(文件&#x2F;etc&#x2F;nologin不存在)。</li>
</ol>
<p>首先查看当前登录的用户名是parallels。</p>
<p><img src="https://pica.zhimg.com/80/v2-cdc7b7aed2db8158ea6eeb482fcadee0_1440w.png" alt="截屏2022-05-17 21.31.38.png"></p>
<p>使用test    用户来登录系统，然后查看当前登录的用户名。</p>
<p><img src="https://pic2.zhimg.com/80/v2-6f2d3e98f7e8c5ba554d10c47f08be59_1440w.png" alt="截屏2022-05-17 21.33.19.png"></p>
<p>使用logout或者exit命令退出test用户，然后在查看当前登录用户是否为parallels。</p>
<p><img src="https://pic2.zhimg.com/80/v2-6f2d3e98f7e8c5ba554d10c47f08be59_1440w.png" alt="img"></p>
<ol start="2">
<li>使用login命令来登录系统(文件&#x2F;etc&#x2F;nologin存在)。</li>
</ol>
<p>首先查看当前登录的用户名是parallels。</p>
<p>在&#x2F;etc目录下新创建一个nologin文件，使用如下命令创建：</p>
<p><code>sudo touch /etc/nologin</code></p>
<p>发现使用test用户是无法登录系统的，只有使用root用户才能登录系统。</p>
<h3 id="使用su命令切换用户身份"><a href="#使用su命令切换用户身份" class="headerlink" title="使用su命令切换用户身份"></a>使用su命令切换用户身份</h3><p>su命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号的密码。 </p>
<p>当使用su命令切换用户后，使用exit命令退出当前身份，返回原有登录用户身份。</p>
<p>注：如果当前用户身份是root，则使用su命令切换到其他用户的时候不需要相应用户的密码</p>
<p>命令格式：<code>su [命令参数] 参数</code></p>
<p>参数为登录的用户名，如果没有参数，则默认切换为root用户。</p>
<p>常见命令参数</p>
<ul>
<li>-c&lt;指令&gt;或–command&#x3D;&lt;指令&gt;：执行完指定的指令后，即恢复原来的身份；</li>
<li>-l或–login：改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,logname。此外，也会变更PATH变量；</li>
<li>-m,-p或–preserve-environment：变更身份时，不要变更环境变量；</li>
<li>s<shell>或–shell&#x3D;<shell>：指定要执行的shell。</li>
</ul>
<p>su命令所有使用者都可以执行。</p>
<p>案例演示:</p>
<ol>
<li>使用su命令切换当前用户身份(不改变当前工作目录)。</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-a3edb5c1caf53250c70364feb7675c44_1440w.png?source=d16d100b" alt="img"></p>
<ol start="2">
<li>使用su命令切换当前用户身份(改变当前工作目录)。</li>
</ol>
<p><img src="https://pica.zhimg.com/80/v2-4b268df03f89c301fb2afb2a601e452e_1440w.png" alt="img"></p>
<ol start="3">
<li>利用-c命令参数实现执行完毕相应的命令立马返回当前用户</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-6e1cc71d9b639a1f76c2198e24599a4e_1440w.png?source=d16d100b" alt="img"><br>或者如下也行<br><img src="https://pic2.zhimg.com/80/v2-ed4d916345d18f5d708fcdb476eeca75_1440w.png" alt="截屏2022-05-17 21.54.57.png"></p>
<h1 id="Linux之文件-x2F-目录搜索"><a href="#Linux之文件-x2F-目录搜索" class="headerlink" title="Linux之文件&#x2F;目录搜索"></a>Linux之文件&#x2F;目录搜索</h1><h2 id="查询命令-locate"><a href="#查询命令-locate" class="headerlink" title="查询命令-locate"></a>查询命令-locate</h2><p><code>locate</code>命令用来查找文件或目录。</p>
<p>locate命令要比其他查找文件命令（例如:find）快得多，原因在于它不搜索具体目录，而是搜索一个数据库<code>/var/lib/mlocate/mlocate.db</code></p>
<p><code>/var/lib/mlocate/mlocate.db</code>这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，因此，我们在用locate查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</p>
<p>locate具体命令如下：</p>
<p><code>locate　命令参数　文件/目录</code></p>
<p>常用命令参数如下：</p>
<ul>
<li>-c, –count            只输出找到的数量；</li>
<li>-d, –database DBPATH  使用DBPATH指定的数据库，而不是默认数据库&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db；</li>
<li>-i, –ignore-case      忽略大小写；</li>
<li>-q, –quiet            安静模式，不会显示任何错误讯息；</li>
<li>-e, –existing         只显示当前存在的文件条目；</li>
</ul>
<p>案例演示：</p>
<ol>
<li>搜索etc目录下以pass开头的文件或目录，具体使用如下命令：</li>
</ol>
<p><code>locate /etc/pass</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ sudo updatedb</span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ locate /etc/pass</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/passwd-</span><br></pre></td></tr></table></figure>

<p>因为updatedb需要root权限，这里需要使用sudo </p>
<ol start="2">
<li>搜索包含passwd字母的文件或目录总个数，具体使用如下命令：</li>
</ol>
<p><code>locate -c passwd</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ locate -c passwd</span><br><span class="line">176</span><br></pre></td></tr></table></figure>

<p><code>updatedb</code></p>
<p>updatedb命令用来创建或更新locate命令所必需的数据库文件。</p>
<p>updatedb命令的执行过程较长，因为在执行时它会遍历整个系统的目录树，并将所有的文件信息写入locate数据库文件中。</p>
<p>具体命令如下：</p>
<p><code>updatedb　命令参数</code></p>
<p>常用参数如下：</p>
<ul>
<li>-o&lt;文件&gt;：忽略默认的数据库文件，使用指定的slocate数据库文件；</li>
<li>-U&lt;目录&gt;：更新指定目录的slocate数据库；</li>
<li>-v：显示执行的详细过程;</li>
</ul>
<p>案例演示：</p>
<ol>
<li>新创建一个testFile文件，更新locate数据库后使用locate命令定位该文件，具体使用如下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch testFile</span><br><span class="line">locate testFile</span><br><span class="line">sudo updatedb</span><br><span class="line">locate testFile</span><br></pre></td></tr></table></figure>

<p>执行情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#更新之前</span><br><span class="line">┌──(kali㉿kali)-[~/trial]</span><br><span class="line">└─$ touch testFile;locate testFile</span><br><span class="line">┌──(kali㉿kali)-[~/trial]</span><br><span class="line">└─$ </span><br><span class="line">#更新数据库之后                                            </span><br><span class="line">┌──(kali㉿kali)-[~/trial]</span><br><span class="line">└─$ sudo updatedb</span><br><span class="line">┌──(kali㉿kali)-[~/trial]</span><br><span class="line">└─$ locate testFile </span><br><span class="line">/home/kali/trial/testFile</span><br></pre></td></tr></table></figure>

<p>可以看到新创建文件后直接使用locate去查找是没有任何结果的，只有更新数据库后才能查找到新创建的文件。</p>
<ol start="2">
<li>删除testFile文件，更新locate数据库后使用locate命令定位该文件，具体使用如下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm testFile</span><br><span class="line">locate testFile</span><br><span class="line">sudo updatedb -U ./</span><br><span class="line">locate testFile</span><br></pre></td></tr></table></figure>

<p>执行情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/trial]</span><br><span class="line">└─$ rm testFile</span><br><span class="line">┌──(kali㉿kali)-[~/trial]</span><br><span class="line">└─$ locate testFile</span><br><span class="line">/home/kali/trial/testFile</span><br><span class="line">#更新数据库之后</span><br><span class="line">┌──(kali㉿kali)-[~/trial]</span><br><span class="line">└─$ sudo updatedb -U /home/kali/trial </span><br><span class="line">┌──(kali㉿kali)-[~/trial]</span><br><span class="line">└─$ locate testFile</span><br><span class="line">┌──(kali㉿kali)-[~/trial]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<p>第三条updatedb命令使用了-U参数，只更新testFile所在目录的数据库，这样速度比较快，如果不使用该参数，则会更新整个文件系统的内容，速度就会比较慢。</p>
<p>删除文件后直接使用locate去查找可以定位到的，原因是没有马上更新数据库，数据库里面仍然有“过时”的信息。</p>
<h2 id="查询命令-which-x2F-whereis"><a href="#查询命令-which-x2F-whereis" class="headerlink" title="查询命令-which&#x2F;whereis"></a>查询命令-which&#x2F;whereis</h2><p>which命令主要是用来查找系统&#x3D;&#x3D;PATH目录下的可执行文件&#x3D;&#x3D;，说白了就是查找那些我们已经安装好的可以直接执行的命令。</p>
<p>whereis命令可以用来查找&#x3D;&#x3D;二进制（命令）、源文件、man文件&#x3D;&#x3D;。与which不同的是这条命令可以是通过文件索引数据库而非PATH来查找的，所以查找的面比which要广。</p>
<h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>which命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<p>which是shell内建命令，内建命令要比系统论命令有比较高的执行效率。</p>
<p>具体命令如下：</p>
<p><code>which　命令</code></p>
<p>案例演示：</p>
<p>使用which命令定位passwd命令的位置，具体使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">which passwd</span><br></pre></td></tr></table></figure>

<p>执行情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ which passwd</span><br><span class="line">/usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p>可以看到passwd命令是存放在&#x2F;usr&#x2F;bin目录下。</p>
<h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>whereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。</p>
<p>具体命令如下：</p>
<p>whereis　命令参数　文件名</p>
<p>常用命令参数如下：</p>
<ul>
<li>-b：只查找二进制文件；</li>
<li>-B&lt;目录&gt;：只在设置的目录下查找二进制文件；</li>
<li>-m：只查找说明文件；</li>
<li>-M&lt;目录&gt;：只在设置的目录下查找说明文件；</li>
<li>-s：只查找原始代码文件；</li>
<li>-S&lt;目录&gt;只在设置的目录下查找原始代码文件；</li>
</ul>
<p>案例演示：</p>
<ol>
<li>使用whereis命令查找passwd命令所有信息，包括二进制文件位置、说明文件位置和源码文件位置，具体使用如下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whereis passwd</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ whereis passwd   </span><br><span class="line">passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1ssl.gz /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用whereis命令仅查找passwd命令二进制文件位置，具体使用如下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whereis -b passwd</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ whereis -b passwd </span><br><span class="line">passwd: /usr/bin/passwd /etc/passwd</span><br></pre></td></tr></table></figure>

<p>可以看到passwd命令存在的位置有两处，分别是&#x2F;usr&#x2F;bin&#x2F;passwd和&#x2F;usr&#x2F;bin&#x2F;X11&#x2F;passwd，那么在我们执行passwd时，如何确定是执行的哪一个，此时我们就可以使用which命令来定位首先被执行的命令位置。</p>
<h2 id="查询命令-find"><a href="#查询命令-find" class="headerlink" title="查询命令-find"></a>查询命令-find</h2><p>find命令与locate命令相比各有优劣，locate命令的查找速度比find命令快的多，但是无法查找最新添加的文件&#x2F;目录以及会查找出来已经过期的文件&#x2F;目录。</p>
<p>相find命令可以按照自定义的方法查找任何文件，功能比较强大。缺点就是查询速度比较慢，因为它会通过遍历硬盘来查找。通常我们会使用find命令，相较于它提供的强大的搜索能力而言，多花费的些微时间不值一提。</p>
<p>find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<p>具体命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find　查找目录　查找参数　查找内容</span><br></pre></td></tr></table></figure>


<p>常用查找参数如下：</p>
<ul>
<li>-amin&lt;+|-分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；</li>
<li>-atime&lt;+|-24小时数&gt;：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；</li>
<li>-cmin&lt;+|-分钟&gt;：查找在指定时间之时被更改过的文件或目录；</li>
<li>-ctime&lt;+|-24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；</li>
<li>-mmin&lt;+|-分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；</li>
<li>-mtime&lt;+|-24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；</li>
<li>-depth：从指定目录下最深层的子目录开始查找；</li>
<li>-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；</li>
<li>-follow：排除符号连接；</li>
<li>-gid&lt;群组识别码&gt;：查找符合指定群组识别码的文件或目录；</li>
<li>-group&lt;群组名称&gt;：查找符合指定群组名称的文件或目录；</li>
<li>-uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；</li>
<li>-user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；</li>
<li>-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</li>
<li>-iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；</li>
<li>-inum&lt;inode编号&gt;：查找符合指定的inode编号的文件或目录；</li>
<li>-newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</li>
<li>-size&lt;+|-|&#x3D;文件大小&gt;：查找符合指定的文件大小的文件；</li>
<li>-type&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；</li>
<li>-a：是前后条件都要满足；</li>
<li>-o ：是满足一个条件就好；</li>
<li>+：表示大于设置值的文件；</li>
<li><ul>
<li>：表示小于设置值的文件；</li>
</ul>
</li>
<li>&#x3D; ：表示等于设置值的文件；</li>
</ul>
<p>案例演示1：</p>
<p>查找&#x2F;etc目录下以update开头以.conf结尾的文件或目录，具体使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo find /etc -name &quot;update*.conf&quot;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ sudo find /etc -name &quot;update*.conf&quot;</span><br><span class="line">/etc/initramfs-tools/update-initramfs.conf</span><br><span class="line">/etc/updatedb.conf</span><br></pre></td></tr></table></figure>

<p>*表示任意字母。这里使用的是正则表达式，正则表达式可以检索、替换那些符合某个模式或规则的文本，非常强大。有兴趣的同学可以了解一下。</p>
<p>案例演示2：</p>
<p>查找&#x2F;etc目录下在超过7天前被访问的文件或目录，具体使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo find /etc -atime +7</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ sudo find /etc -atime +7</span><br><span class="line">/etc/king-phisher/server_config.yml</span><br><span class="line">/etc/postgresql/14/main/environment</span><br><span class="line">/etc/postgresql/14/main/pg_ctl.conf</span><br><span class="line">/etc/postgresql/14/main/postgresql.conf</span><br><span class="line">/etc/postgresql/14/main/pg_hba.conf</span><br><span class="line">/etc/postgresql/14/main/pg_ident.conf</span><br><span class="line">/etc/geoclue/geoclue.conf</span><br></pre></td></tr></table></figure>

<p>案例演示3：</p>
<p>查找&#x2F;etc目录下恰好在7天前被访问的文件或目录，具体使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo find /etc -atime 7</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ sudo find /etc -atime 7 </span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<p>案例演示4：</p>
<p>查找&#x2F;etc目录下在5分钟内被访问的文件或目录，具体使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo find /etc -amin -5</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/etc]</span><br><span class="line">└─$ sudo find /etc -amin -20</span><br><span class="line">/etc/king-phisher</span><br><span class="line">/etc/postgresql/14/main</span><br><span class="line">/etc/postgresql/14/main/conf.d</span><br><span class="line">/etc/geoclue</span><br></pre></td></tr></table></figure>

<h3 id="type-文件类型使用方法"><a href="#type-文件类型使用方法" class="headerlink" title="-type 文件类型使用方法"></a>-type 文件类型使用方法</h3><p>常见文件类型：</p>
<ul>
<li>f：普通文件</li>
<li>l：符号链接</li>
<li>d：目录</li>
<li>c：字符设备</li>
<li>b：块设备</li>
<li>s：套接字</li>
<li>p：Fifo</li>
</ul>
<p>案例演示：</p>
<p>查找&#x2F;etc目录下以my开头的目录，具体使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo find /etc -name &quot;my*&quot; -a -type d</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ sudo find /etc -name &quot;my*&quot; -a -type d   </span><br><span class="line">/etc/mysql</span><br></pre></td></tr></table></figure>

<h3 id="size-lt-x3D-文件大小-gt-使用方法"><a href="#size-lt-x3D-文件大小-gt-使用方法" class="headerlink" title="size &lt;+|-|&#x3D;文件大小&gt;使用方法"></a>size &lt;+|-|&#x3D;文件大小&gt;使用方法</h3><p>常见文件大小单位：</p>
<ul>
<li>b —— 块（512字节）</li>
<li>c —— 字节</li>
<li>w —— 字（2字节）</li>
<li>k —— 千字节</li>
<li>M —— 兆字节</li>
<li>G —— 吉字节</li>
</ul>
<p>案例演示：</p>
<p>查找&#x2F;etc目录下大于1M的文件，具体使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo find /etc -size +1M</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ sudo find /etc -size +1M </span><br><span class="line">/etc/theHarvester/wordlists/dns-big.txt</span><br></pre></td></tr></table></figure>

<h3 id="exec使用方法"><a href="#exec使用方法" class="headerlink" title="-exec使用方法"></a><code>-exec</code>使用方法</h3><p>具体使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find　…　-exec 要执行的命令  &#123;&#125; \;</span><br></pre></td></tr></table></figure>


<p>-exec选项后面跟随着所要执行的命令或脚本，然后是一个空格一对儿{}一个空格和一个;。</p>
<p>注意：要执行的命令和{之间以及}与;之间的空格是不能省略的。</p>
<p>案例演示：</p>
<p>查找&#x2F;etc目录下大于1M的文件&#x2F;目录的详细信息，具体使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo find /etc -size +1M -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ sudo find /etc -size +1M -exec ls -l &#123;&#125; \;</span><br><span class="line">-rw-r--r-- 1 root root 1115633 Nov 25 12:42 /etc/theHarvester/wordlists/dns-big.txt</span><br></pre></td></tr></table></figure>

<h1 id="Linux之文件打包和解压缩"><a href="#Linux之文件打包和解压缩" class="headerlink" title="Linux之文件打包和解压缩"></a>Linux之文件打包和解压缩</h1><h2 id="打包和压缩的区别"><a href="#打包和压缩的区别" class="headerlink" title="打包和压缩的区别"></a>打包和压缩的区别</h2><p>文件打包，有可能仅仅是将多个文件连接成1个文件，并不进行压缩处理。有时候也可能看起来文件变小，那是因为多个文件储存可能造成多余的空间浪费，究其原因是文件储存方式中，分块族造成的。1个族1次只能被1个文件使用，虽然1个文件能使用多个族，但最后1个族未必能填满。因此，大量的文件就会造成很多浪费。而连接成1个文件后，只会浪费1个族。压缩就不一样了，它不但把文件连在一起，还进行特定算法的压缩。对于txt这类很“松”的文件，可以大大减小文件的大小</p>
<h2 id="tar打包命令"><a href="#tar打包命令" class="headerlink" title="tar打包命令"></a>tar打包命令</h2><p>tar（tape archive的简写）工具可完成许多功能，其名称源于它的原始功能－创建和读取归档文件和备份磁带。如今，该工具常用来将多个文件或多个目录打包成一个tar文件，或者将某个tar文件分解开。</p>
<p>打包:<br>tar命令可以将多个文件&#x2F;目录进行打包，将多个文件生成一个文件，生成的文件后缀为.tar。</p>
<p>具体的打包命令为:<br><code>tar -cvf 生成的tar包名 要打包的文件或者是目录</code></p>
<p>常用的参数命令：</p>
<ul>
<li>-c 建立新的归档文件</li>
<li>-v 处理过程中输出相关信息</li>
<li>-f 对普通文件操作</li>
</ul>
<p>解包：<br>tar命令可以将已经打包好的文件解压出来。</p>
<p>具体解包命令如下:<br><code>tar　-xvf　解压包名 -C 解压到指定目录</code></p>
<p>常用的参数：</p>
<ul>
<li>-x 或 –ext\fract 或 –get：从备份文件中还原文件</li>
<li>-v 处理过程中输出相关信息</li>
<li>-f 对普通文件进行操作</li>
<li>-C &lt;目标路径&gt; 切换到指定的目录</li>
</ul>
<p>ps:如果不使用-C(大写)参数，则默认解压到当前目录下。</p>
<h2 id="文件压缩命令"><a href="#文件压缩命令" class="headerlink" title="文件压缩命令"></a>文件压缩命令</h2><p>Linux下存在多个文件压缩工具，常用的有bzip2、gzip和zip。这三个工具都是可以将一个文件进行压缩操作，使其在不丢失任何信息的情况下占用较少的磁盘空间<br>对于多文件&#x2F;目录的压缩操作分为两步：</p>
<ol>
<li>将其进行打包</li>
<li>将打包过后的文件进行压缩操作。</li>
</ol>
<h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>bzip2命令用于创建和管理（包括解压缩）.bz2格式的压缩包。</p>
<p>具体命令如下：<br><code>bzip2　命令参数　指定要压缩的文件</code></p>
<ul>
<li>-z或–compress：强制执行压缩；</li>
<li>-d或–decompress：执行解压缩；</li>
<li>-f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；</li>
<li>-v或–verbose：压缩或解压缩文件时，显示详细的信息；</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-b42ce538c7788075a09af03c46919de7_1440w.png" alt="img"></p>
<h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p>gzip命令用于创建和管理（包括解压缩）.gz格式的压缩包。</p>
<p>具体命令如下：<br><code>gzip　命令参数　指定要压缩的文件</code></p>
<p>常用命令参数如下：</p>
<ul>
<li>-d或–decompress或—-uncompress：解开压缩文件；</li>
<li>-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；</li>
<li>-l或——list：列出压缩文件的相关信息；</li>
<li>-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；</li>
<li>-v或——verbose：显示指令执行过程；</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-41a8bf0cbf36afa1df267e3de583f83f_1440w.png" alt="img"></p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip命令对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有.zip扩展名的压缩文件。</p>
<p>具体命令如下：<br><code>zip　命令参数　指定生成的压缩文件名　要被压缩的文件/目录列表</code></p>
<p>常用命令参数如下：</p>
<ul>
<li>-d：从压缩文件内删除指定的文件；</li>
<li>-q：不显示指令执行过程；</li>
<li>-r：递归处理，将指定目录下的所有文件和子目录一并处理；</li>
<li>-v：显示指令执行过程或显示版本信息；</li>
<li>-u：更换较新的文件到压缩文件内；</li>
<li>-x&lt;范本样式&gt;：压缩时排除符合条件的文件；</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-9dd464d71df248e65262a1f214bc09e7_1440w.png" alt="img"></p>
<h3 id="tar命令进行压缩"><a href="#tar命令进行压缩" class="headerlink" title="tar命令进行压缩"></a>tar命令进行压缩</h3><p>可以使用tar命令一步就实现对多文件&#x2F;目录进行压缩操作。</p>
<h4 id="采用bzip2方式执行tar命令进行压缩"><a href="#采用bzip2方式执行tar命令进行压缩" class="headerlink" title="采用bzip2方式执行tar命令进行压缩"></a>采用bzip2方式执行tar命令进行压缩</h4><p>具体命令如下：<br><code>tar -jcvf　指定生成的压缩文件名　要被压缩的文件/目录列表</code></p>
<p>常用命令参数如下：</p>
<ul>
<li>-c 建立新的归档文件；</li>
<li>-v 处理过程中输出相关信息；</li>
<li>-f 对普通文件操作；</li>
<li>-j 以bzip2对文件&#x2F;目录进行压缩；</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-8aaf0456c7efac96190cfb060d770eeb_1440w.png" alt="img"></p>
<h4 id="采用gzip进行压缩"><a href="#采用gzip进行压缩" class="headerlink" title="采用gzip进行压缩"></a>采用gzip进行压缩</h4><p>具体命令如下：<br><code>tar　-zcvf　指定生成的压缩文件名　要被压缩的文件/目录列表</code></p>
<p>常用命令参数如下：</p>
<p>-c 建立新的归档文件；<br>-v 处理过程中输出相关信息；<br>-f 对普通文件操作；<br>-z 以gzip对文件&#x2F;目录进行压缩；</p>
<p><img src="https://pica.zhimg.com/80/v2-02c04e92a06377ae24a04f9370c1ce16_1440w.png" alt="img"></p>
<h2 id="文件解压缩命令"><a href="#文件解压缩命令" class="headerlink" title="文件解压缩命令"></a>文件解压缩命令</h2><p>针对bzip2、gzip和zip这三种压缩工具生成的压缩包，我们可以使用bunzip2、gunzip和unzip命令对其进行解压缩。</p>
<h3 id="bunzip2"><a href="#bunzip2" class="headerlink" title="bunzip2"></a>bunzip2</h3><p> bunzip2命令解压缩由bzip2指令创建的.bz2压缩包。使用bzip2 -d命令也可以将.bz2压缩包进行解压。</p>
<p>具体命令如下：<br><code>bunzip2　命令参数　指定要解压的文件</code></p>
<p>常用命令参数如下：</p>
<ul>
<li>-f或–force：解压缩时，若输出的文件与现有文件同名时，预设不会覆盖现有的文件；</li>
<li>-k或–keep：在解压缩后，预设会删除原来的压缩文件。若要保留压缩文件，请使用此参数；</li>
<li>-v或–verbose：解压缩文件时，显示详细的信息；</li>
</ul>
<h3 id="gunzip"><a href="#gunzip" class="headerlink" title="gunzip"></a>gunzip</h3><p>gunzip命令解压缩由gzip指令创建的.gz压缩包。使用gzip -d命令也可以将.gz压缩包进行解压。</p>
<p>具体命令如下：<br><code>gunzip　命令参数　指定要解压的文件</code></p>
<p>常用命令参数如下：</p>
<ul>
<li>-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；</li>
<li>-l或-list：列出压缩文件的相关信息；</li>
<li>-q或-quiet：不显示警告信息；</li>
<li>-r或-recursive：递归处理，将指定目录下的所有文件及子目录一并处理；</li>
<li>-v或-verbose：显示指令执行过程；</li>
</ul>
<h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p>unzip命令用于解压缩由zip命令压缩的.zip压缩包。</p>
<p>具体命令如下：<br><code>unzip　命令参数　指定要解压的文件</code></p>
<p>常用命令参数如下：</p>
<ul>
<li>-q：执行时不显示任何信息；</li>
<li>-n：解压缩时不要覆盖原有的文件；</li>
<li>-d&lt;目录&gt;：指定文件解压缩后所要存储的目录；</li>
</ul>
]]></content>
      <categories>
        <category>CS学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>linux基础</tag>
        <tag>命令行</tag>
        <tag>cs工具</tag>
      </tags>
  </entry>
  <entry>
    <title>周计划（6.13-6.19）</title>
    <url>/2022/06/13/%E5%91%A8%E8%AE%A1%E5%88%92%EF%BC%886-13-6-19%EF%BC%89/</url>
    <content><![CDATA[<ul>
<li><input checked="" disabled="" type="checkbox"> 微积分通过考试宝典整体过一遍，熟悉知识体系。</li>
<li><input checked="" disabled="" type="checkbox"> 大学物理通过宝典和精选习题也是整体的过一遍。</li>
<li><input checked="" disabled="" type="checkbox"> 英语卓越篇八个单元，每天复习一个单元，认真积累词汇，读懂文章。词汇每日过一遍。</li>
<li><input checked="" disabled="" type="checkbox"> 近代史的vlog的ddl尽快完成。</li>
</ul>
<p>总结：</p>
<p>微积分基本完成，大学物理还没开始复习，英语也只完成了两个单元，效率低下，面对即将到来的考试你准备怎么应对？大物好好复习！！！</p>
]]></content>
      <categories>
        <category>心路</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>个人反思</tag>
      </tags>
  </entry>
  <entry>
    <title>个人计划（暑假）</title>
    <url>/2022/06/01/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="对于这个暑假的一些具体安排"><a href="#对于这个暑假的一些具体安排" class="headerlink" title="对于这个暑假的一些具体安排"></a>对于这个暑假的一些具体安排</h1><p>最近觉得心里乱乱的，感觉什么都想学，什么都想知道，但是人的精力的确是有限的，所以在此厘清自己的头绪，学会取舍。</p>
<span id="more"></span>
<p>按照我认为从急到缓</p>
<ul>
<li><input disabled="" type="checkbox"> 科研老师交予的任务，三本书，还有斯坦福的视频，这是一定要完成的任务！</li>
<li><input disabled="" type="checkbox"> C++（郑莉）的学习和数据结构（清华数据结构），算法（先就PAT乙）的学习，努力提高自己的代码能力，练习配上地大的实习和头哥的实验。</li>
<li><input disabled="" type="checkbox"> 学会一些基础的CS工具，linux，git，py，cmake和docker等等，对自己的要求就是浅尝辄止，不许过多浪费时间。</li>
<li><input disabled="" type="checkbox"> 至少要有做自己的项目的经历，初步的想法是用自己买的服务器搭一个网页游戏，从中学习前后端的知识，边做边学。还有一个就是利用c++写一个小游戏，参照地大的项目，目的是提高自己对C++的理解，然后熟悉程序开发的过程，OOP(面向对象编程)可以先搁置。</li>
</ul>
]]></content>
      <categories>
        <category>心路</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>个人反思</tag>
      </tags>
  </entry>
  <entry>
    <title>警醒</title>
    <url>/2022/06/15/%E8%AD%A6%E9%86%92/</url>
    <content><![CDATA[<h1 id="戒骄戒躁，专注当下！"><a href="#戒骄戒躁，专注当下！" class="headerlink" title="戒骄戒躁，专注当下！"></a>戒骄戒躁，专注当下！</h1>]]></content>
      <categories>
        <category>心路</category>
      </categories>
      <tags>
        <tag>个人反思</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础知识</title>
    <url>/2022/06/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>说明：全是初步的了解，并不深入，等到计网再说。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="端点和会话"><a href="#端点和会话" class="headerlink" title="端点和会话"></a>端点和会话</h2><p>端点（endpoint） 就是指网络上能够发送或者接受数据的一台设备。两个端点之间的通信被称为会话 （conversation）。</p>
<h2 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h2><p>32位二进制数，常用点分十进制表示，会随着设备接入局域网的变化而变化，一部分由网络号组成，另一部分是主机号，由子网掩码决定。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>32位二进制数，形式类似于1111…0000,直接与ip地址进行与运算得到的是网络号，取反与ip地址进行与运算得到的是主机号。</p>
<h2 id="Mac地址"><a href="#Mac地址" class="headerlink" title="Mac地址"></a>Mac地址</h2><p>48位二进制数<br>每台主机的唯一的身份标识（出厂后恒定不变），网卡的物理地址，在局域网中与ip地址成映射关系。而且网卡通过比对数据包内发送目标的mac地址直接判断是否送入操作系统。</p>
<p><strong>ip和mac的关系类似于收件地址和身份证号类似，收件地址可能会发生改变，但是身份证号一定不会改变。</strong></p>
<span id="more"></span>

<h2 id="Question-为什么有了ip地址还需要mac地址？"><a href="#Question-为什么有了ip地址还需要mac地址？" class="headerlink" title="Question: 为什么有了ip地址还需要mac地址？"></a>Question: 为什么有了ip地址还需要mac地址？</h2><p>ip地址等价于快递包裹上的收件人地址。快递员通过收件人地址将包裹在出发地到目的地之间连出一条线，然后通过不同地区之间的物流中转最后将包裹送到收件人的手中。<br>MAC地址等价于快递包裹上的收件人姓名。MAC地址更多是用于确认对方信息而存在的。就如同快递跨越几个城市来到你面前，快递员需要和你确认以下收件人是否正确，才会把包裹交给你一样。<br>比如在学校里同一个班级（抽象成局域网）的学生大家互相都认识，互相交流就不需要借助学号（这里抽象成ip地址），直接喊名字（mac地址）即可。</p>
<p>虽然有ip地址，但是它在局域网中不起作用，因为arp协议（Address Resolution Protocol）是用于网络中寻址的，而在局域网中所有主机互相可见。（除此之外，局域网中ip地址最多是在arp广播时，作为收到包的主机解包时判定的依据，判定自己是否为目的主机，从而选择是否回应arp应答）。</p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>网关（Gateway）就是一个网络连接到另一个网络的“关口”。也就是网络关卡。例如交换机和路由器。<br>网关又称网间连接器、协议转换器。默认网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。</p>
<p>&#x3D;&#x3D;说明：由于历史的原因，许多有关TCP&#x2F;IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用都是路由来接入网络，因此通常指的网关就是路由器的IP&#x3D;&#x3D;</p>
<h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768描述了 UDP。<br>Internet 的传输层有两个主要协议，互为补充。无连接的是 UDP，它除了给应用程序发送数据包功能并允许它们在所需的层次上架构自己的协议之外，几乎没有做什么特别的事情。<strong>面向连接</strong>的是 TCP，该协议几乎做了所有的事情。</p>
<h3 id="TCP（比较屌也比较难）"><a href="#TCP（比较屌也比较难）" class="headerlink" title="TCP（比较屌也比较难）"></a>TCP（比较屌也比较难）</h3><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。<br>TCP旨在适应支持多网络应用的分层协议层次结构。 连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠TCP提供可靠的通信服务。TCP假设它可以从较低级别的协议获得简单的，可能不可靠的数据报服务。 原则上，TCP应该能够在从硬线连接到分组交换或电路交换网络的各种通信系统之上操作。</p>
<h4 id="建立连接和拆除连接"><a href="#建立连接和拆除连接" class="headerlink" title="建立连接和拆除连接"></a>建立连接和拆除连接</h4><p><strong>建立连接：</strong><br><img src="https://pic2.zhimg.com/80/v2-58989b47296d51404a93456e33fb8bce_1440w.png" alt="image"><br><strong>拆除连接：</strong><br><img src="https://pica.zhimg.com/80/v2-ef569f7a16193c4f5ec462900790a730_1440w.png" alt="image"></p>
<h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><p>TCP是一种面向广域网的通信协议，目的是在跨越多个网络通信时，为两个通信端点之间提供一条具有下列特点的通信方式：</p>
<ul>
<li>基于流的方式；</li>
<li>面向连接；</li>
<li>可靠通信方式；</li>
<li>在网络状况不佳的时候尽量降低系统由于重传带来的带宽开销；</li>
<li>通信连接维护是面向通信的两个端点的，而不考虑中间网段和节点。</li>
</ul>
<p>为满足TCP协议的这些特点，TCP协议做了如下的规定：<br>①数据分片：在发送端对用户数据进行分片，在接收端进行重组，由TCP确定分片的大小并控制分片和重组；<br>②到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认；<br>③超时重发：发送方在发送分片时启动超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片；<br>④滑动窗口：TCP连接每一方的接收缓冲空间大小都固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出；<br>⑤失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层；<br>⑥重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据；<br>⑦数据校验：TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验和有差错，TCP将丢弃这个分片，并不确认收到此报文段导致对端超时并重发。</p>
<h3 id="简单的区分"><a href="#简单的区分" class="headerlink" title="简单的区分"></a>简单的区分</h3><p>Internet 的传输层有两个主要协议，互为补充。<strong>无连接</strong>的是UDP，它除了给应用程序发送数据包功能并允许它们在所需的层次上架构自己的协议之外，几乎没有做什么特别的事情。<strong>面向连接</strong>的是 TCP，该协议几乎做了所有的事情。</p>
<h2 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h2><h3 id="DHCP简介"><a href="#DHCP简介" class="headerlink" title="DHCP简介"></a>DHCP简介</h3><p><strong>DHCP</strong>（Dynamic Host Configuration Protocol <strong>动态主机配置协议</strong>）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。<br>通常被应用在大型的局域网络环境中，主要作用是集中地管理、分配IP地址，使网络环境中的主机动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。</p>
<p>DHCP协议采用客户端&#x2F;服务器模型，主机地址的动态分配任务由网络主机驱动。当DHCP服务器接收到来自网络主机申请地址的信息时，才会向网络主机发送相关的地址配置等信息，以实现网络主机地址信息的动态配置。</p>
<h3 id="DHCP功能"><a href="#DHCP功能" class="headerlink" title="DHCP功能"></a>DHCP功能</h3><p>DHCP具有以下功能： </p>
<ol>
<li>保证任何IP地址在同一时刻只能由一台DHCP客户机所使用。</li>
<li>DHCP应当可以给用户分配永久固定的IP地址。 </li>
<li>DHCP应当可以同用其他方法获得IP地址的主机共存（如手工配置IP地址的主机）。 </li>
<li>DHCP服务器应当向现有的BOOTP客户端提供服务。</li>
</ol>
<h3 id="地址分配方法"><a href="#地址分配方法" class="headerlink" title="地址分配方法"></a>地址分配方法</h3><p>DHCP有三种机制分配IP地址：</p>
<ol>
<li>自动分配方式（Automatic Allocation），DHCP服务器为主机指定一个永久性的IP地址，一旦DHCP客户端第一次成功从DHCP服务器端租用到IP地址后，就可以永久性的使用该地址。 </li>
<li>动态分配方式（Dynamic Allocation），DHCP服务器给主机指定一个具有时间限制的IP地址，时间到期或主机明确表示放弃该地址时，该地址可以被其他主机使用。</li>
<li>手工分配方式（Manual Allocation），客户端的IP地址是由网络管理员指定的，DHCP服务器只是将指定的IP地址告诉客户端主机。<br>三种地址分配方式中，只有动态分配可以重复使用客户端不再需要的地址。</li>
</ol>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h3 id="FTP简介"><a href="#FTP简介" class="headerlink" title="FTP简介"></a>FTP简介</h3><p>文件传输协议（File Transfer Protocol，FTP）是用于在网络上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 <strong>TCP 传输而不是 UDP</strong>， 客户在和服务器建立连接前要经过一个“三次握手”的过程，保证客户与服务器之间的连接是可靠的，而且是面向连接，为数据传输提供可靠保证。<br>FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而，用户并不真正登录到自己想要存取的计算机上面而成为完全用户，可用FTP程序访问远程资源，实现用户往返传输文件、目录管理以及访问电子邮件等等，即使双方计算机可能配有不同的操作系统和文件存储方式。</p>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>FTP的传输有两种方式：ASCII、二进制。</p>
<h4 id="ASCII传输方式"><a href="#ASCII传输方式" class="headerlink" title="ASCII传输方式"></a>ASCII传输方式</h4><p>假定用户正在拷贝的文件包含的简单ASCII码文本，如果在远程机器上运行的不是UNIX，当文件传输时ftp通常会自动地调整文件的内容以便于把文件解释成另外那台计算机存储文本文件的格式。但是常常有这样的情况，用户正在传输的文件包含的不是文本文件，它们可能是程序，数据库，字处理文件或者压缩文件。在拷贝任何非文本文件之前，用binary 命令告诉ftp逐字拷贝。</p>
<h4 id="二进制传输模式"><a href="#二进制传输模式" class="headerlink" title="二进制传输模式"></a>二进制传输模式</h4><p>在二进制传输中，保存文件的位序，以便原始和拷贝的是逐位一一对应的。即使目的地机器上包含位序列的文件是没意义的。例如，macintosh以二进制方式传送可执行文件到Windows系统，在对方系统上，此文件不能执行。如在ASCII方式下传输二进制文件，即使不需要也仍会转译。这会损坏数据。（ASCII方式一般假设每一字符的第一有效位无意义，因为ASCII字符组合不使用它。如果传输二进制文件，所有的位都是重要的。）</p>
<h3 id="FTP支持两种模式"><a href="#FTP支持两种模式" class="headerlink" title="FTP支持两种模式"></a>FTP支持两种模式</h3><p>FTP客户端发起FTP会话，与FTP服务器建立相应的连接。FTP会话期间要建立控制信息进程与数据进程两个连接。控制连接不能完成传输数据的任务，只能用来传送FTP执行的内部命令以及命令的响应等控制信息；数据连接是服务器与客户端之间传输文件的连接，是全双工的，允许同时进行双向数据传输。当数据传输完成后，数据连接会撤消，再回到FTP会话状态，直到控制连接被撤消，并退出会话为止。<br>FTP支持两种模式：Standard（PORT方式，主动方式），Passive（PASV，被动方式）。</p>
<h4 id="Port模式（主动模式）"><a href="#Port模式（主动模式）" class="headerlink" title="Port模式（主动模式）"></a>Port模式（主动模式）</h4><p>FTP 客户端首先和服务器的TCP 21端口建立连接，用来发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令。PORT命令包含了客户端用什么端口接收数据。在传送数据的时候，服务器端通过自己的TCP 20端口连接至客户端的指定端口发送数据。FTP server必须和客户端建立一个新的连接用来传送数据。</p>
<h4 id="Passive模式（被动模式）"><a href="#Passive模式（被动模式）" class="headerlink" title="Passive模式（被动模式）"></a>Passive模式（被动模式）</h4><p>建立控制通道和Standard模式类似，但建立连接后发送Pasv命令。服务器收到Pasv命令后，打开一个临时端口（端口号大于1023小于65535）并且通知客户端在这个端口上传送数据的请求，客户端连接FTP服务器此端口，然后FTP服务器将通过这个端口传送数据。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>很多防火墙在设置的时候都是不允许接受外部发起的连接的，所以许多位于防火墙后或内网的FTP服务器不支持PASV模式，因为客户端无法穿过防火墙打开FTP服务器的高端端口；而许多内网的客户端不能用PORT模式登陆FTP服务器，因为从服务器的TCP 20无法和内部网络的客户端建立一个新的连接，造成无法工作。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。请求和响应消息的头以ASCII形式给出。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>HTTP诞生之初主要是应用于WEB端内容获取，那时候内容还不像现在这样丰富，排版也没那么精美，用户交互的场景几乎没有。对于这种简单的获取网页内容的场景，HTTP表现得还算不错。但随着互联网的发展和WEB2.0的诞生，更多的内容开始被展示（更多的图片文件），排版变得更精美（更多的CSS），更复杂的交互也被引入（更多的JS）。用户打开一个网站首页所加载的数据总量和请求的个数也在不断增加。</p>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>请求报文格式如下：</p>
<p>请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体</p>
<p>请求行以方法字段开始，后面分别是URL字段和HTTP协议版本字段，并以CRLF结尾。SP是分隔符。除了在最后的CRLF序列中CF和LF是必需的之外，其他都可以不要。有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。</p>
<h4 id="应答报文"><a href="#应答报文" class="headerlink" title="应答报文"></a>应答报文</h4><p>应答报文格式如下：</p>
<p>状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体</p>
<p>状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。</p>
<p><strong><a href="https://blog.csdn.net/m0_45861545/article/details/120835738">HTTP报文详解点击此处</a></strong></p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>服务器接收HTTP请求后，会向客户端发送响应信息，放置第一行。其中最重要的<br>就是状态码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<h4 id="状态码类型—第1位数字"><a href="#状态码类型—第1位数字" class="headerlink" title="状态码类型—第1位数字"></a>状态码类型—第1位数字</h4><ul>
<li>1**：请求被成功接收，继续处理；范围100~101</li>
<li>2**：服务器成功处理请求；范围200~206</li>
<li>3**：访问资源被移动，告知客服端重新发送新请求；范围300~305</li>
<li>4**：客户端错误，服务器无法处理请求，如访问资源不存在；范围400~415</li>
<li>5**：服务器错误；范围500~505</li>
</ul>
<h4 id="常见HTTP状态码"><a href="#常见HTTP状态码" class="headerlink" title="常见HTTP状态码"></a>常见HTTP状态码</h4><ul>
<li>200：客户端请求成功（常见）</li>
<li>302：重定向</li>
<li>404：请求资源不存在（常见）</li>
<li>400：客户端请求语法错误，不能被服务器所理解</li>
<li>401：访问未被授权</li>
<li>403：服务器收到请求，但拒绝服务</li>
<li>500：服务器内部错误（常见）</li>
<li>503：服务器当前不能处理，一段时间后可能可以</li>
</ul>
<p>具体细节参看《<strong>图解HTTP</strong>》</p>
<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="内网通信（局域网）"><a href="#内网通信（局域网）" class="headerlink" title="内网通信（局域网）"></a>内网通信（局域网）</h2><h3 id="以太网（ethernet）"><a href="#以太网（ethernet）" class="headerlink" title="以太网（ethernet）"></a>以太网（ethernet）</h3><p>以太网是一种计算机<strong>局域网</strong>技术。</p>
<h3 id="内网通信过程"><a href="#内网通信过程" class="headerlink" title="内网通信过程"></a>内网通信过程</h3><p>这里所说的内网，一般来说是指局域网（LAN）。我们说两个终端 在同一个内网中，其本质是指两个终端的网络号是相同的。如果两个终端在同一个 内网中，那么其通信方式如下</p>
<p><img src="https://pic3.zhimg.com/80/v2-28645c18e711eac7b6a3262f94556ecc_1440w.png" alt="image"></p>
<h3 id="ARP简介"><a href="#ARP简介" class="headerlink" title="ARP简介"></a>ARP简介</h3><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。主机发送信息时将包含目标IP地址的ARP请求<strong>广播(broadcast)</strong> 到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询<strong>ARP缓存</strong>以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。</p>
<h4 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h4><p>ARP欺骗（ARP spoofing），又称ARP毒化（ARP poisoning，网络上多译为ARP病毒）或ARP攻击，是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网络上特定计算机或所有计算机无法正常连线。</p>
<h4 id="free-ARP"><a href="#free-ARP" class="headerlink" title="free ARP"></a>free ARP</h4><ol>
<li>看有无地址冲突</li>
<li>更新自己的ARP缓存</li>
</ol>
<h2 id="因特网（Internet）通信过程"><a href="#因特网（Internet）通信过程" class="headerlink" title="因特网（Internet）通信过程"></a>因特网（Internet）通信过程</h2><p>如果主机在 Internet 上，则目标地址与源地址不在同一个内网中，也就是说他们的 IP 地址的网络号部分并不一致，此时需要将数据包发送到“默认网关”上进行路由选择，具体的通信过程如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-5188517210eac6afb96e4046cbbe65c6_1440w.png" alt="image"></p>
]]></content>
      <categories>
        <category>CS学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影</title>
    <url>/2022/06/01/%E6%91%84%E5%BD%B1/</url>
    <content><![CDATA[<h3 id="分享一些自己的拍摄照片"><a href="#分享一些自己的拍摄照片" class="headerlink" title="分享一些自己的拍摄照片"></a>分享一些自己的拍摄照片</h3><p><img src="https://pic2.zhimg.com/80/v2-880f14a452020c4bc2960951c42b20f1_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<span id="more"></span>

<p><img src="https://pic1.zhimg.com/80/v2-a0f11cbb7953ba01a890c23e3be6c63f_1440w.jpeg" alt="夕阳"></p>
<p><img src="https://pic3.zhimg.com/80/v2-9649a908558db3a70a77ae9e1fb8d33a_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pica.zhimg.com/80/v2-717a3602b5c57865874b88f563cee104_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic2.zhimg.com/80/v2-319e56149a37bb79ebf398313ee0ef8a_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic1.zhimg.com/80/v2-d4104a182c25846d796f9334e94d860c_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pica.zhimg.com/80/v2-35c2028c96d3af9820616de6388003f4_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic1.zhimg.com/80/v2-def6aca439de3567dfd35065ee0e61e7_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic3.zhimg.com/80/v2-ac2fd89cd4fa0896b54d2b6a20b66486_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic2.zhimg.com/80/v2-eaff4c547270c0b99608f71874ebc9a5_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pica.zhimg.com/80/v2-3e75354556b09d68ea7385b9c5610748_1440w.png?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic1.zhimg.com/80/v2-64aae8ff73271c57cab8a5c79b7b29db_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pica.zhimg.com/80/v2-648b81c8736de915dc8bc2e4c0385f8b_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic3.zhimg.com/80/v2-ea5211faa3dd7dfaed9a64bd645866a3_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic3.zhimg.com/80/v2-e6e138d6ab805a903e7ad780a0c4fff1_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic3.zhimg.com/80/v2-835481f1de4157b12dfc740d54378618_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic1.zhimg.com/80/v2-a90e6cd32db008c98c24a931b83e1dd1_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic3.zhimg.com/80/v2-1b4264e392f1b8337c353a01adf72601_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic3.zhimg.com/80/v2-4ce7490f09c5f2f2909cdbad626b9308_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic1.zhimg.com/80/v2-5a3bfbbb36571fecb58251160155c7fb_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
<p><img src="https://pic1.zhimg.com/80/v2-bf9de49eb26f598c9af619bd40a3bdfc_1440w.jpeg?source=d16d100b" alt="夕阳"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>美景</tag>
      </tags>
  </entry>
  <entry>
    <title>认清差距，努力追赶</title>
    <url>/2022/05/22/%E8%AE%A4%E6%B8%85%E5%B7%AE%E8%B7%9D%EF%BC%8C%E5%8A%AA%E5%8A%9B%E8%BF%BD%E8%B5%B6/</url>
    <content><![CDATA[<h2 id="对于今天学院csp选拔赛的感受"><a href="#对于今天学院csp选拔赛的感受" class="headerlink" title="对于今天学院csp选拔赛的感受"></a>对于今天学院csp选拔赛的感受</h2><p>我对于今天的几道编程题颇有感触，跟我之前做过的完全是不同的感觉，我以为的程序是能够运行成功，但是真正的题目数据是非常大的，且有严格的时间限制，所以必须要考虑到算法的效率。</p>
<span id="more"></span>

<p>也终于明白了一味的暴力求解是很呆的方式，完全想不到效率更高的算法， 这也与我并没有接触过相关题目有关系，这个暑假提高自己的代码能力迫在眉睫，数据结构这门课需要好好吃透，然后往算法方面去提高自己的能力。</p>
<h2 id="正视自己，摆平心态"><a href="#正视自己，摆平心态" class="headerlink" title="正视自己，摆平心态"></a>正视自己，摆平心态</h2><p>对于在校的学习生活压力是很大的，今天的选拔赛让我看到了许多同龄人的身影，他们的代码能力又有的甚至能够和大二的匹敌，让我知道自己其实是非常的不足，当然也不应该自暴自弃，只能说去努力的赶超吧。</p>
<p>勇于直面前方的艰难险阻，才能到达成功的彼岸！</p>
]]></content>
      <categories>
        <category>心路</category>
      </categories>
      <tags>
        <tag>个人反思</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
